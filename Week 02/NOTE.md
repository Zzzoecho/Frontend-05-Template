学习笔记

## 鼠标事件
触发 mousedown 时, 可以用 e.button 的值区分点击的是鼠标的哪个键
```javascript
document.addEventListener('mousedown', e => {
    console.log(e.button)
    if (e.button === 2) {
      console.log('右键')
    } else if (e.button === 0) {
      console.log('左键')
    } else if (e.button === 1) {
       console.log('滚轮')
    }
})

// 去掉默认的右键菜单
document.addEventListener('contextmenu', e => {
    e.preventDefault()
})
```
## 寻路算法

广度优先算法 (BFS)
1. 设定起点 A, 放入队列中
2. 从队列中取出第一个节点 B, 并检验它是否为目标. 如果是则返回结果
3. 否则将 B 的上下左右未检验过的相邻节点加入队列中
4. 若队列为空代表整张图都搜寻过了, 但没有找到目标

缺点: 
- 效率低 O(n^2)
- 每个节点没有权值, 无法定义优先级, 不能找到最优路线

深度优先算法 (DFS)
执行过程和广度优先一样, 只不过换成栈的操作, 总是处理最新加入的节点


push - 推入
pop - 取出最后一个
shift - 取出第一个
unshift - 在第一位插入

队列(先进先出): 广度优先
栈(先进后出): 深度优先

### Dijkstra 算法
A* 的无启发式函数版
适用于有障碍物的地图求最短路径, 可为不同地形设置不同的移动消耗. 如: 文明中, 在森林和山地形移动时, 需要消耗更多的移动力
优先级队列, 按移动消耗排序, 总移动消耗越低优先级越高

缺点:
- 搜索目标不具有方向性
- 不是最短路径


### 贪婪最佳优先搜索 Greed-Best-First-Search
总是尝试向离目标节点更近的方向探索, 使用计算当前节点到目标节点的曼哈顿距离来判断. 
由于曼哈顿距离只在两点之间没有障碍物的情况下才与实际距离相等, 一般情况下曼哈顿距离总是小于实际距离.
因此, 当节点间不存在障碍物时, 该算法可以保证找出最短路径. 有障碍物时, 无法保证最短

```javascript
// 假设当前节点坐标是 (x,y), 目标节点坐标是(x1,y1)
distance = abs(x1 - x) + abs(y1 - y)
```


### A* 启发式搜索
A*算法合并了 Dijkstra 算法 和 贪婪最佳优先搜索的优点
计算节点到目标节点的距离

`F(N) = G(N) + H(N)`
- G(N): Dijkstra 算法中计算的, 从起点到当前节点 N 的移动消耗
- H(N): 贪婪最佳优先搜索中计算的, 当前节点 N 到目标节点的距离

H(N) 是影响 A*算法 运行效率的关键

1. 极端情况, H(N) = 0, A*算法就退化为Dijkstra算法. 可以保证找到最短路径
2. H(N) < 节点N到终点的实际距离, A* 算法可以保证找到最短路径. H(N)比实际距离越小, A*需要探索的节点就越多, 性能就会变差
3. H(N) = 节点N到终点的实际距离, A* 算法可以一直保持最优路径.
4. H(N) >> G(N), A*会退化成 贪婪最佳优先搜索, 不能保证找到最短路径

由于障碍物的存在, H(N)一般总是情况2. 优化时可以给 H(N) 更高一点的权重 `F(N) = G(N) + H(N)*1.01`

在我们的例子中, 因为没有不同地形只分了能走和不能走, 所以移动消耗就是当前节点到起点的距离

### 曼哈顿距离
图片中红线代表曼哈顿距离, 绿线代表欧式距离, 也是直线距离, 蓝线和黄线都是等价的曼哈顿距离
![曼哈顿距离](https://bkimg.cdn.bcebos.com/pic/8326cffc1e178a8208d61b83f603738da977e82f?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1)

`d(i,j) = |xi - x| + |yi - y|`
